let CI = ../../dependencies/CI.dhall

let Bash = CI.Bash

let Workflow = CI.Workflow

let Step = Workflow.Step

let VersionBump = ./VersionBump.dhall

let Script = ../Script.dhall

let Name =
      { Type = { prefix : Text, suffix : Text }
      , default = { prefix = "", suffix = "" }
      }

let Name =
          Name
      /\  { deploy = Name::{ suffix = "-deploy" }
          , src = Name::{ suffix = "-src" }
          , unchanged = Name::{ suffix = "" }
          , apply =
              \(derived : Name.Type) ->
              \(name : Text) ->
                "${derived.prefix}${name}${derived.suffix}"
          }

let Options =
      { versionBump : VersionBump.Type
      , applyVersionScript : Bash.Type
      , derivedBranch : Name.Type
      , sourceTag : Name.Type
      , derivedTag : Name.Type
      , commitMessage : Text
      }

let default =
        { versionBump = VersionBump.default
        , applyVersionScript = [] : Bash.Type
        , derivedBranch = Name.deploy
        , sourceTag = Name.src
        , derivedTag = Name.unchanged
        , commitMessage = "Autogenerated"
        }
      : Options

let derivedCommitVar = "DERIVED_COMMIT"

let derivedCommitScript =
      \(opts : Options) ->
          Script.exportCommiterEnv Script.githubActionsBot
        # [ "git status"
          , "git commit -m \"${opts.commitMessage}\""
          , "${derivedCommitVar}=\"\$(git rev-parse HEAD)\""
          ]

let versionTagSpecs =
      \(opts : Options) ->
        let versionTag = "v\${${VersionBump.exportedEnvName opts.versionBump}}"

        let spec =
              \(commit : Text) ->
              \(name : Name.Type) ->
                "${commit}:refs/tags/${Name.apply name versionTag}"

        in  [ spec "\$GITHUB_SHA" opts.sourceTag
            , spec "\$${derivedCommitVar}" opts.derivedTag
            ]

let pushSpecs =
      \(specs : List Text) ->
        [ "git push origin ${Bash.doubleQuoteArgs specs}" ]

let publishSteps =
    {-
    The publish step makes a deploy commit, but
    creates different tags / branches based on context:
     - push deployBranch (always, forced)
     - push both $VERSION_TAG[source, if present] and $VERSION_TAG[derived] (for a push event)
    -}
      \(opts : Options) ->
        let derivedBranchName =
              Name.apply opts.derivedBranch "\${BRANCH_REF#/refs/heads/}"

        let deployBranchSpec =
              "+\$${derivedCommitVar}:refs/heads/${derivedBranchName}"

        let pushScript =
              Bash.join
                [ pushSpecs [ deployBranchSpec ]
                , Bash.`if`
                    "[ \"\$GITHUB_EVENT_NAME\" = 'push' -a -n \"\${${VersionBump.exportedEnvName
                                                                       opts.versionBump}:-}\" ]"
                    (pushSpecs (versionTagSpecs opts))
                ]

        let tagStep =
              VersionBump.step
                (opts.versionBump // { action = VersionBump.Action.Generate })

        let commitAndPushStep =
                    Step.bash
                      ( Bash.join
                          [ opts.applyVersionScript
                          , derivedCommitScript opts
                          , pushScript
                          ]
                      )
                //  { name = Some "Publish derived commit"
                    , env = Some
                        ( toMap
                            { BRANCH_REF =
                                Workflow.expr "github.base_ref || github.ref"
                            }
                        )
                    }
              : Step.Type

        in  [ tagStep, commitAndPushStep ]

in  { Type = Options, Name, default, publishSteps }
